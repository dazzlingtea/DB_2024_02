/*
 * 검색 CASE 표현식
 */
-- 일치하지 않으면 다음 WHEN절로 넘어간다
-- 급여가 10000 이상이면 상위
-- 급여가 6000 이상이면 중위
-- 급여가 1000 이상이면 하위

SELECT employee_id, salary
   ,CASE
      WHEN salary >= 10000 THEN '상위'
      WHEN salary >= 6000 THEN '중위'
      WHEN salary >= 1000 THEN '하위'
   END
FROM employees;

SELECT employee_id, salary
   ,CASE
      WHEN salary >= 10000 THEN '상위'
      WHEN salary >= 6000 THEN '중위'
      ELSE '하위'
   END
FROM employees;

   
SELECT employee_id, salary
   ,CASE
      WHEN salary >= 1000 THEN '하위'
      WHEN salary >= 6000 THEN '중위'
      WHEN salary >= 10000 THEN '상위'
   END
FROM employees;

-- 단순 CASE 표현식과 NULL
-- 커미션 비율이 존재하면 Y, 존재하지 않으면 N
-- =(비교연산자)를 사용하므로 NULL을 판단하지 못한다
SELECT employee_id, commission_pct
	,CASE commission_pct WHEN NULL THEN 'N'
		ELSE 'Y'
	END AS "커미션 존재 여부"
FROM employees;


-- 검색 CASE 표현식과 NULL
SELECT employee_id, commission_pct
	,CASE WHEN commission_pct IS NULL THEN 'N'
		ELSE 'Y'
	END AS "커미션 존재 여부"
FROM employees;

/*
 * 실습.
 * 법정 최저급여가 3300일때, 사원들의 평균 급여 구하기
 * 급여가 3300 미만 사원 : 3300으로 급여 적용
 * 급여가 3300 이상 사원 : 기존 급여 적용
 */

-- 급여가 3300 미만이다 -> 이 조건이 거짓이라는 것은 급여가 3300 이상이다

SELECT
	avg(salary)
	,avg(CASE WHEN salary < 3300 THEN 3300 ELSE salary END) AS "평균 급여"
FROM employees;

-- 집계함수와 일반 컬럼은 같이 조회할 수 없다
-- GROUP BY 기준 컬럼이 아닌 일반컬럼은 조회할 수 없다
/*
 * 실습.
 * 법정 최저급여가 3300일 때 최저급여를 위반하는 사원과
 * 최저급여를 충족하는 사원의 수, 총 사원의 수 구하기
 */
-- else가 없으면 null이 됨

SELECT sum(CASE WHEN salary < 3300 THEN 1 ELSE 0 end) AS "최저급여 위반"
	,sum(CASE WHEN salary >= 3300 THEN 1 ELSE 0 end) AS "최저급여 충족"
	,count(CASE WHEN salary >= 3300 THEN salary END)
	,count(*)
FROM employees;

/*
 * 등가 조인
 */

DROP TABLE test1;
DROP TABLE test2;

-- test1 테이블 생성
CREATE TABLE test1(
   col1 number,
   col2 varchar2(1000)
);

-- test2 테이블 생성
CREATE TABLE test2( 
   col1 number,
   col3 varchar2(1000)
);


-- test1, test2 테이블에 데이터 삽입
BEGIN 

INSERT INTO test1
VALUES (1, 'A');

INSERT INTO test1
VALUES (2, 'B');

INSERT INTO test1
VALUES (3, 'C');

INSERT INTO test2
VALUES (1, '가');

INSERT INTO test2
VALUES (5, '나');

INSERT INTO test2
VALUES (1, '다');

END;

SELECT * FROM test1;
SELECT * FROM test2;


/* test1 테이블           	   test2 테이블
 * col1      col3              col1      col3
 * =============               ================
 * 1        A                  1         가
 * 2        B                  5         나
 * 3        C                  1         다
 */

-- 오라클
-- test1 col1 값과 test2 col1 값이 같은 행들끼리 연결한다
SELECT *
FROM test1, TEST2
WHERE test1.col1 = test2.col1;

-- 안시
SELECT *
FROM test1 INNER JOIN TEST2
ON test1.col1 = test2.col1;

SELECT test1.col1, test2.col3
FROM test1 INNER JOIN TEST2 
ON test1.col1 = test2.col1;












